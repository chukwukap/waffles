generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// NOTE: To accurately determine if a user *joined* a game (i.e., actually started playing),
// we need a model that records this action explicitly.
// The following 'GameParticipant' model records each time a user joins (starts) a game.
// This is separate from ticket purchase.

model User {
  id                 Int                 @id @default(autoincrement())
  fid                Int                 @unique
  name               String?
  imageUrl           String?
  wallet             String?             @unique
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  invitations        Referral[]          @relation("UserInviter")
  referrals          Referral[]          @relation("UserInvitee")
  tickets            Ticket[]
  scores             Score[]
  chats              Chat[]
  answers            Answer[]
  gameParticipants   GameParticipant[] // <-- users who have really joined (played) games
  roundCompletions   RoundCompletion[]
  waitlist           Waitlist?
  waitlistReferrals  Waitlist[]          @relation("WaitlistReferral")
  notificationTokens NotificationToken[]
}

model Referral {
  id         Int       @id @default(autoincrement())
  code       String    @unique
  inviter    User      @relation("UserInviter", fields: [inviterId], references: [id])
  inviterId  Int
  invitee    User?     @relation("UserInvitee", fields: [inviteeId], references: [id])
  inviteeId  Int?
  createdAt  DateTime  @default(now())
  acceptedAt DateTime?

  @@index([code])
}

model Game {
  id           Int               @id @default(autoincrement())
  name         String
  description  String?
  startTime    DateTime
  endTime      DateTime
  createdAt    DateTime          @default(now())
  questions    Question[]
  rounds       Round[]
  tickets      Ticket[]
  scores       Score[]
  chats        Chat[]
  config       GameConfig?
  answers      Answer[]
  participants GameParticipant[] // <-- users who have really joined (played) this game
  roundCompletions RoundCompletion[]
}

model Round {
  id        Int        @id @default(autoincrement())
  game      Game       @relation(fields: [gameId], references: [id])
  gameId    Int
  roundNum  Int // 1-based index for round (e.g., 1, 2, 3, ...)
  questions Question[]
  completions RoundCompletion[]

  @@unique([gameId, roundNum])
  @@index([gameId])
}

model GameParticipant {
  id       Int      @id @default(autoincrement())
  game     Game     @relation(fields: [gameId], references: [id])
  gameId   Int
  user     User     @relation(fields: [userId], references: [id])
  userId   Int
  joinedAt DateTime @default(now())
  // This table accurately records that a user "joined" (started playing) a game.

  @@unique([gameId, userId])
  @@index([userId])
  @@index([gameId])
}

model RoundCompletion {
  id          Int      @id @default(autoincrement())
  game        Game     @relation(fields: [gameId], references: [id])
  gameId      Int
  round       Round    @relation(fields: [roundId], references: [id])
  roundId     Int
  user        User     @relation(fields: [userId], references: [id])
  userId      Int
  completedAt DateTime @default(now())
  // Records when a user completes all questions in a round

  @@unique([userId, gameId, roundId])
  @@index([userId])
  @@index([gameId])
  @@index([roundId])
}

model GameConfig {
  id                Int     @id @default(autoincrement())
  gameId            Int     @unique
  game              Game    @relation(fields: [gameId], references: [id])
  ticketPrice       Int     @default(50)
  additionPrizePool Int     @default(0)
  roundTimeLimit    Int     @default(15) // round countdown time
  questionTimeLimit Int     @default(10) // question countdown time
  questionsPerGame  Int     @default(9)
  theme             String // FOOTBALL | MOVIES | ANIME | POLITICS | CRYPTO enum
  scoreMultiplier   Float   @default(1.0)
  scorePenalty      Float?
  maxPlayers        Int     @default(200)
  soundEnabled      Boolean @default(true)
}

model Question {
  id            Int      @id @default(autoincrement())
  game          Game     @relation(fields: [gameId], references: [id])
  gameId        Int
  round         Round    @relation(fields: [roundId], references: [id])
  roundId       Int
  text          String
  imageUrl      String
  soundUrl      String?
  options       String[]
  correctAnswer String
  createdAt     DateTime @default(now())
  answers       Answer[]

  @@index([gameId])
  @@index([roundId])
}

model Ticket {
  id          Int       @id @default(autoincrement())
  code        String    @unique
  game        Game      @relation(fields: [gameId], references: [id])
  gameId      Int
  user        User      @relation(fields: [userId], references: [id])
  userId      Int
  amountUSDC  Float
  txHash      String?
  status      String    @default("pending")
  purchasedAt DateTime  @default(now())
  usedAt      DateTime?

  @@unique([gameId, userId])
}

model Score {
  id        Int      @id @default(autoincrement())
  user      User     @relation(fields: [userId], references: [id])
  userId    Int
  game      Game     @relation(fields: [gameId], references: [id])
  gameId    Int
  points    Int      @default(0)
  createdAt DateTime @default(now())

  @@unique([userId, gameId])
}

model Chat {
  id        Int      @id @default(autoincrement())
  user      User     @relation(fields: [userId], references: [id])
  userId    Int
  game      Game     @relation(fields: [gameId], references: [id])
  gameId    Int
  message   String
  createdAt DateTime @default(now())
}

model Answer {
  id         Int      @id @default(autoincrement())
  user       User     @relation(fields: [userId], references: [id])
  userId     Int
  game       Game     @relation(fields: [gameId], references: [id])
  gameId     Int
  question   Question @relation(fields: [questionId], references: [id])
  questionId Int
  selected   String
  isCorrect  Boolean
  timeTaken  Int
  createdAt  DateTime @default(now())

  @@unique([userId, gameId, questionId])
}

model Waitlist {
  id     Int  @id @default(autoincrement())
  user   User @relation(fields: [userId], references: [id])
  userId Int  @unique

  referredBy     Int?
  referredByUser User? @relation("WaitlistReferral", fields: [referredBy], references: [id])

  createdAt DateTime @default(now())
  invites   Int      @default(0)

  @@index([createdAt])
}

model NotificationToken {
  id        Int      @id @default(autoincrement())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    Int
  appFid    Int // The FID of the client app (e.g., Base app is 309857)
  token     String
  url       String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Tokens are unique per user-client combination
  @@unique([userId, appFid])
  @@index([userId])
  @@index([appFid])
  @@index([token])
}
