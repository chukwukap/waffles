generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ==========================================
// 1. USER & GROWTH (The "Account" Layer)
// ==========================================

model User {
  id       Int     @id @default(autoincrement())
  fid      Int     @unique // Farcaster ID
  username String? // 'name' is vague. 'username' implies display handle.
  pfpUrl   String? // 'imageUrl' is generic. 'pfpUrl' is specific.
  wallet   String? @unique

  // -- VIRAL LOOP --
  inviteCode  String     @unique // REMOVED @default(cuid())
  inviteQuota Int        @default(3) // Renamed: "Quota" implies a limit
  status      UserStatus @default(WAITLIST)

  // -- RELATIONSHIPS --
  invitedBy   User?            @relation("ReferralTree", fields: [invitedById], references: [id])
  invitedById Int?
  invites     User[]           @relation("ReferralTree")
  rewards     ReferralReward[] @relation("InviterRewards")

  // -- DATA --
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tickets Ticket[]
  games   GamePlayer[] // The games they actually played
  answers Answer[]
  notifs  NotificationToken[]
  chats   Chat[]
}

enum UserStatus {
  WAITLIST
  ACTIVE
  BANNED
}

// RENAMED: Focuses on the outcome (The Reward), not the process (Tracking)
model ReferralReward {
  id        Int  @id @default(autoincrement())
  inviter   User @relation("InviterRewards", fields: [inviterId], references: [id])
  inviterId Int

  inviteeId Int @unique // One reward per new user

  status RewardStatus @default(PENDING)
  amount Int          @default(0) // Points or USDC

  createdAt  DateTime  @default(now())
  unlockedAt DateTime? // When invitee played their first game

  @@index([inviterId])
}

enum RewardStatus {
  PENDING // Invitee registered
  UNLOCKED // Invitee played
  CLAIMED // Money sent to wallet
}

// ==========================================
// 2. THE ARENA (The "Game" Layer)
// ==========================================

model Game {
  id Int @id @default(autoincrement())

  // -- INFO --
  title       String // 'name' is okay, 'title' is better for events
  description String?
  theme       GameTheme
  status      GameStatus @default(SCHEDULED)

  // -- TIMING --
  startsAt DateTime // 'startTime' -> 'startsAt' (Standard convention)
  endsAt   DateTime

  // -- CONFIGURATION (Merged from GameConfig) --
  entryFee         Int @default(50)
  prizePool        Int @default(0)
  roundDurationSec Int @default(15) // _Sec suffix makes units obvious
  questionCount    Int @default(9)
  maxPlayers       Int @default(200)

  // -- DATA --
  questions Question[]
  tickets   Ticket[]
  players   GamePlayer[] // The Leaderboard
  answers   Answer[]
  chats     Chat[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status, startsAt]) // For finding the "next game" quickly
}

enum GameTheme {
  FOOTBALL
  MOVIES
  ANIME
  POLITICS
  CRYPTO
}

enum GameStatus {
  SCHEDULED
  LIVE
  ENDED
  CANCELLED
}

model Question {
  id     Int  @id @default(autoincrement())
  game   Game @relation(fields: [gameId], references: [id])
  gameId Int

  roundIndex Int @default(1) // e.g. 1, 2, 3... 

  // -- CONTENT --
  content      String // 'text' is fine, 'content' is broader
  mediaUrl     String? // 'imageUrl' -> 'mediaUrl' (allows video/audio later)
  soundUrl     String? // Added this from your original schema
  options      String[]
  correctIndex Int // RENAMED: Explicitly tells you it's an array index (0-3)

  durationSec Int @default(10)

  answers Answer[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([gameId, roundIndex])
}

// ==========================================
// 3. THE ACTION (The "Play" Layer)
// ==========================================

// The "Receipt"
model Ticket {
  id     Int    @id @default(autoincrement())
  code   String @unique @default(cuid())
  game   Game   @relation(fields: [gameId], references: [id])
  gameId Int
  user   User   @relation(fields: [userId], references: [id])
  userId Int

  amountUSDC Float
  txHash     String?
  status     TicketStatus @default(PENDING)

  purchasedAt DateTime  @default(now())
  redeemedAt  DateTime? // 'usedAt' -> 'redeemedAt' (More transactional)
  updatedAt   DateTime  @updatedAt

  @@unique([gameId, userId])
}

enum TicketStatus {
  PENDING
  PAID
  FAILED
  REDEEMED // They have entered the lobby
}

// RENAMED: GameParticipant -> GamePlayer
// This is the "Live State" of a user in a specific game.
model GamePlayer {
  id     Int  @id @default(autoincrement())
  game   Game @relation(fields: [gameId], references: [id])
  gameId Int
  user   User @relation(fields: [userId], references: [id])
  userId Int

  claimedAt DateTime? // Timestamp when the prize was claimed

  // -- LEADERBOARD DATA --
  score        Int      @default(0)
  rank         Int? // Null until game ends
  isEliminated Boolean  @default(false)
  joinedAt     DateTime @default(now())

  // Faster Lookups: We want to find the top scorers of a specific game quickly
  @@unique([gameId, userId])
  @@index([gameId, score(sort: Desc)])
}

// The "Audit Log"
model Answer {
  id         Int      @id @default(autoincrement())
  user       User     @relation(fields: [userId], references: [id])
  userId     Int
  game       Game     @relation(fields: [gameId], references: [id])
  gameId     Int
  question   Question @relation(fields: [questionId], references: [id])
  questionId Int

  selectedIndex Int // RENAMED: Matches correctIndex
  isCorrect     Boolean
  latencyMs     Int // 'timeTaken' -> 'latencyMs' (Technical precision)
  pointsEarned  Int     @default(0)

  createdAt DateTime @default(now())

  @@unique([userId, questionId]) // User can't answer the same question twice
  @@index([gameId, userId]) // For quickly finding all of a user's answers in a game
}

// ==========================================
// 4. UTILS
// ==========================================

model Chat {
  id        Int      @id @default(autoincrement())
  game      Game     @relation(fields: [gameId], references: [id])
  gameId    Int
  user      User     @relation(fields: [userId], references: [id])
  userId    Int
  text      String // 'message' -> 'text' (Shorter)
  createdAt DateTime @default(now())

  @@index([gameId, createdAt]) // For loading chat history fast
}

model NotificationToken {
  id        Int      @id @default(autoincrement())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    Int
  appFid    Int
  token     String
  url       String // Added this back from your original schema
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, appFid])
  @@index([token])
}
