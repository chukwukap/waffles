generator client {
  provider = "prisma-client"
  output   = "./generated"
}

datasource db {
  provider = "postgresql"
}

// ==========================================
// 1. USER & GROWTH (The "Account" Layer)
// ==========================================

model User {
  id       Int     @id @default(autoincrement())
  fid      Int     @unique
  username String?
  pfpUrl   String?
  wallet   String? @unique

  // -- ADMIN --
  role     UserRole @default(USER)
  password String? // Hashed password for admin accounts

  // -- VIRAL LOOP --
  inviteCode     String     @unique
  inviteQuota    Int        @default(3)
  status         UserStatus @default(NONE)
  completedTasks String[]   @default([])
  waitlistPoints Int        @default(0)

  // -- RELATIONSHIPS --
  invitedBy   User?            @relation("ReferralTree", fields: [invitedById], references: [id])
  invitedById Int?
  invites     User[]           @relation("ReferralTree")
  rewards     ReferralReward[] @relation("InviterRewards")

  // -- DATA --
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tickets   Ticket[]
  games     GamePlayer[]
  answers   Answer[]
  notifs    NotificationToken[]
  chats     Chat[]
  auditLogs AuditLog[]
}

enum UserRole {
  USER
  ADMIN
}

enum UserStatus {
  NONE
  WAITLIST
  ACTIVE
  BANNED
}

model ReferralReward {
  id        Int  @id @default(autoincrement())
  inviter   User @relation("InviterRewards", fields: [inviterId], references: [id])
  inviterId Int

  inviteeId Int @unique // One reward per new user

  status RewardStatus @default(PENDING)
  amount Int          @default(0) // Points or USDC

  createdAt  DateTime  @default(now())
  unlockedAt DateTime? // When invitee played their first game

  @@index([inviterId])
}

enum RewardStatus {
  PENDING // Invitee registered
  UNLOCKED // Invitee played
  CLAIMED // Money sent to wallet
}

// ==========================================
// 2. THE ARENA (The "Game" Layer)
// ==========================================

model Game {
  id Int @id @default(autoincrement())

  // -- INFO --
  title       String
  description String?
  theme       GameTheme
  coverUrl    String
  status      GameStatus @default(SCHEDULED)

  // -- TIMING --
  startsAt DateTime
  endsAt   DateTime

  // -- CONFIGURATION --
  entryFee         Int @default(50)
  prizePool        Int @default(0)
  roundDurationSec Int @default(15)
  maxPlayers       Int @default(200)

  // -- DATA --
  questions Question[]
  tickets   Ticket[]
  players   GamePlayer[]
  answers   Answer[]
  chats     Chat[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status, startsAt]) // For finding the "next game" quickly
}

enum GameTheme {
  FOOTBALL
  MOVIES
  ANIME
  POLITICS
  CRYPTO
}

enum GameStatus {
  SCHEDULED
  LIVE
  ENDED
  CANCELLED
}

model Question {
  id     Int  @id @default(autoincrement())
  game   Game @relation(fields: [gameId], references: [id], onDelete: Cascade)
  gameId Int

  roundIndex Int @default(1) // e.g. 1, 2, 3... 
  order      Int @default(0) // For ordering within a round 

  // -- CONTENT --
  content      String
  mediaUrl     String // Optional image/video for the question
  soundUrl     String // Optional audio for the question
  options      String[]
  correctIndex Int

  durationSec Int @default(10)

  answers Answer[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([gameId, roundIndex])
}

// ==========================================
// 3. THE ACTION (The "Play" Layer)
// ==========================================

// The "Receipt"
model Ticket {
  id     Int    @id @default(autoincrement())
  code   String @unique @default(cuid())
  game   Game   @relation(fields: [gameId], references: [id], onDelete: Cascade)
  gameId Int
  user   User   @relation(fields: [userId], references: [id])
  userId Int

  amountUSDC Float
  txHash     String?
  status     TicketStatus @default(PENDING)

  purchasedAt DateTime  @default(now())
  redeemedAt  DateTime?
  updatedAt   DateTime  @updatedAt

  @@unique([gameId, userId])
}

enum TicketStatus {
  PENDING
  PAID
  FAILED
  REDEEMED // They have entered the lobby
}

// This is the "Live State" of a user in a specific game.
model GamePlayer {
  id     Int  @id @default(autoincrement())
  game   Game @relation(fields: [gameId], references: [id], onDelete: Cascade)
  gameId Int
  user   User @relation(fields: [userId], references: [id])
  userId Int

  claimedAt DateTime? // Timestamp when the prize was claimed

  // -- LEADERBOARD DATA --
  score    Int      @default(0)
  rank     Int? // Null until game ends
  joinedAt DateTime @default(now())

  // Faster Lookups: We want to find the top scorers of a specific game quickly
  @@unique([gameId, userId])
  @@index([gameId, score(sort: Desc)])
}

// The "Audit Log"
model Answer {
  id         Int      @id @default(autoincrement())
  user       User     @relation(fields: [userId], references: [id])
  userId     Int
  game       Game     @relation(fields: [gameId], references: [id], onDelete: Cascade)
  gameId     Int
  question   Question @relation(fields: [questionId], references: [id])
  questionId Int

  selectedIndex Int // Stores the index of the selected option (or -1 for no answer)
  isCorrect     Boolean
  pointsEarned  Int     @default(0)
  latencyMs     Int // Time taken in milliseconds

  createdAt DateTime @default(now())

  @@unique([userId, questionId]) // User can't answer the same question twice
  // Performance indexes
  @@index([userId, isCorrect], name: "user_correct_idx")
  @@index([gameId, userId], name: "game_user_idx") // For quickly finding all of a user's answers in a game
}

// ==========================================
// 4. UTILS
// ==========================================

model Chat {
  id        Int      @id @default(autoincrement())
  game      Game     @relation(fields: [gameId], references: [id], onDelete: Cascade)
  gameId    Int
  user      User     @relation(fields: [userId], references: [id])
  userId    Int
  text      String
  createdAt DateTime @default(now())

  @@index([gameId, createdAt]) // For loading chat history fast
}

model NotificationToken {
  id        Int      @id @default(autoincrement())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    Int
  appFid    Int
  token     String
  url       String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, appFid])
  @@index([token])
}

// ==========================================
// 5. ADMIN (Audit & Logging)
// ==========================================

model AuditLog {
  id      Int  @id @default(autoincrement())
  admin   User @relation(fields: [adminId], references: [id])
  adminId Int

  action     String // "CREATE_GAME", "BAN_USER", "UPDATE_GAME", etc.
  entityType String // "Game", "User", "Question", etc.
  entityId   Int? // ID of affected entity
  details    Json? // Additional context (before/after values, etc.)
  ip         String? // Admin's IP address
  createdAt  DateTime @default(now())

  @@index([adminId, createdAt])
  @@index([entityType, entityId])
}
