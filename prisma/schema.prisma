generator client {
  provider = "prisma-client"
  output   = "./generated"
}

datasource db {
  provider = "postgresql"
}

// ==========================================
// 1. USER & GROWTH (The "Account" Layer)
// ==========================================

model User {
  id       Int     @id @default(autoincrement())
  fid      Int     @unique
  username String? @db.VarChar(100)
  pfpUrl   String? @db.VarChar(500)
  wallet   String? @unique @db.VarChar(42)

  // -- ADMIN --
  role     UserRole @default(USER)
  password String?

  // -- REFERRAL (who brought them into the system) --
  referredBy   User?  @relation("Referrals", fields: [referredById], references: [id])
  referredById Int?
  referrals    User[] @relation("Referrals")

  // -- INVITE SYSTEM --
  inviteCode    String       @unique @db.VarChar(25)
  inviteQuota   Int          @default(3) @db.SmallInt
  redeemedCodes InviteCode[]

  // -- ACCESS CONTROL --
  hasGameAccess   Boolean   @default(false)
  accessGrantedAt DateTime?
  accessGrantedBy Int?

  // -- BAN --
  isBanned Boolean   @default(false)
  bannedAt DateTime?
  bannedBy Int?

  // -- WAITLIST --
  joinedWaitlistAt DateTime?
  waitlistPoints   Int              @default(0)
  waitlistRank     Int? // Pre-computed rank (updated periodically)
  completedQuests  CompletedQuest[]

  // -- REWARD TRACKING --
  rewards ReferralReward[] @relation("InviterRewards")

  // -- TIMESTAMPS --
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // -- RELATIONS --
  entries   GameEntry[]
  chats     Chat[]
  notifs    NotificationToken[]
  auditLogs AuditLog[]

  @@index([waitlistPoints(sort: Desc)])
}

enum UserRole {
  USER
  ADMIN
}

model ReferralReward {
  id        Int  @id @default(autoincrement())
  inviter   User @relation("InviterRewards", fields: [inviterId], references: [id])
  inviterId Int

  inviteeId Int @unique

  status RewardStatus @default(PENDING)
  amount Int          @default(0) @db.SmallInt

  createdAt  DateTime  @default(now())
  unlockedAt DateTime?

  @@index([inviterId])
}

enum RewardStatus {
  PENDING
  UNLOCKED
  CLAIMED
}

// ==========================================
// 1.5 QUEST SYSTEM
// ==========================================

enum QuestType {
  LINK
  FARCASTER_FOLLOW
  FARCASTER_CAST
  FARCASTER_RECAST
  REFERRAL
  CUSTOM
}

enum QuestCategory {
  SOCIAL
  ONBOARDING
  REFERRAL
  ENGAGEMENT
  SPECIAL
}

enum RepeatFrequency {
  ONCE
  DAILY
  WEEKLY
  UNLIMITED
}

model Quest {
  id   Int    @id @default(autoincrement())
  slug String @unique @db.VarChar(50)

  // -- DISPLAY --
  title       String  @db.VarChar(100)
  description String  @db.VarChar(500)
  iconUrl     String? @db.VarChar(255)

  // -- CATEGORIZATION --
  category  QuestCategory @default(SOCIAL)
  sortOrder Int           @default(0) @db.SmallInt

  // -- REWARDS --
  points Int @default(0) @db.SmallInt

  // -- ACTION CONFIG --
  type      QuestType
  actionUrl String?   @db.VarChar(500)
  castHash  String?   @db.VarChar(66)
  targetFid Int?

  // -- REQUIREMENTS --
  requiredCount Int @default(1) @db.SmallInt

  // -- SCHEDULING --
  isActive Boolean   @default(true)
  startsAt DateTime?
  endsAt   DateTime?

  // -- REPEATABILITY --
  repeatFrequency RepeatFrequency @default(ONCE)

  // -- TIMESTAMPS --
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // -- RELATIONS --
  completions CompletedQuest[]
}

model CompletedQuest {
  id Int @id @default(autoincrement())

  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId Int

  quest   Quest @relation(fields: [questId], references: [id], onDelete: Cascade)
  questId Int

  completedAt   DateTime @default(now())
  pointsAwarded Int      @default(0) @db.SmallInt

  isApproved Boolean   @default(true)
  approvedBy Int?
  approvedAt DateTime?

  @@unique([userId, questId])
  @@index([userId])
  @@index([questId])
}

// ==========================================
// 2. THE ARENA (The "Game" Layer)
// ==========================================

model Game {
  id String @id @default(cuid())

  // -- ON-CHAIN IDENTITY (random bytes32, stored as 0x-prefixed hex string) --
  onchainId String? @unique @db.VarChar(66)

  // -- INFO --
  title       String    @db.VarChar(100)
  description String?   @db.VarChar(1000)
  theme       GameTheme
  coverUrl    String?   @db.VarChar(255)

  // -- TIMING (source of truth for game phase) --
  startsAt DateTime
  endsAt   DateTime

  // -- PRICING (3 tier prices) --
  tierPrices Float[] @default([5, 10, 25])

  // -- PRE-COMPUTED STATS (updated atomically) --
  prizePool   Float @default(0) // Sum of ticket prices
  playerCount Int   @default(0) // Count of entries

  // -- CONFIGURATION --
  roundBreakSec Int @default(20) @db.SmallInt
  maxPlayers    Int @default(200) @db.SmallInt

  // -- SETTLEMENT (set when game ends and results are submitted on-chain) --
  merkleRoot       String?   @db.VarChar(66) // 0x-prefixed, 32 bytes
  settlementTxHash String?   @db.VarChar(66) // TX that submitted results
  settledAt        DateTime?

  // -- RELATIONS --
  questions Question[]
  entries   GameEntry[]
  chats     Chat[]

  // -- TIMESTAMPS --
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // -- INDEXES --
  @@index([startsAt])
  @@index([endsAt])
}

enum GameTheme {
  FOOTBALL
  MOVIES
  ANIME
  POLITICS
  CRYPTO
  GENERAL
}

// NOTE: GameStatus enum REMOVED
// Phase is now derived from startsAt/endsAt:
// - now < startsAt => SCHEDULED
// - startsAt <= now < endsAt => LIVE
// - now >= endsAt => ENDED

model Question {
  id     Int    @id @default(autoincrement())
  game   Game   @relation(fields: [gameId], references: [id], onDelete: Cascade)
  gameId String

  // -- ORDERING --
  roundIndex   Int @default(1) @db.SmallInt
  orderInRound Int @default(0) @db.SmallInt

  // -- CONTENT --
  content      String   @db.VarChar(1000)
  mediaUrl     String?  @db.VarChar(255)
  soundUrl     String?  @db.VarChar(255)
  options      String[] // Native Postgres array
  correctIndex Int      @db.SmallInt

  // -- TIMING & SCORING --
  durationSec Int @default(10) @db.SmallInt
  points      Int @default(100) @db.SmallInt

  // -- TIMESTAMPS --
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([gameId, roundIndex, orderInRound])
}

// ==========================================
// 3. GAME ENTRY (Consolidates Ticket + GamePlayer)
// ==========================================
// Single record per user per game: payment + progress + results

model GameEntry {
  id Int @id @default(autoincrement())

  game   Game   @relation(fields: [gameId], references: [id], onDelete: Cascade)
  gameId String

  user   User @relation(fields: [userId], references: [id])
  userId Int

  // -- PAYMENT --
  txHash      String?   @unique @db.VarChar(66)
  payerWallet String?   @db.VarChar(42) // Wallet address used for this purchase
  paidAmount  Float? // Tier price paid
  paidAt      DateTime?

  // -- PROGRESS (updated per answer) --
  score    Int @default(0)
  answered Int @default(0) @db.SmallInt

  // -- ANSWERS (embedded JSON for speed) --
  // Format: { "questionId": { "selected": 0, "correct": true, "points": 100, "ms": 2340 } }
  answers Json @default("{}")

  // -- FINAL RESULTS (set when game ends) --
  rank      Int?      @db.SmallInt
  prize     Float?
  claimedAt DateTime?

  // -- MERKLE PROOF (set during settlement for winners, rank 1-3) --
  // Stored as JSON array of hex strings: ["0x...", "0x...", ...]
  merkleProof  Json?
  merkleAmount String? @db.VarChar(78) // Prize amount in token units (bigint as string)

  // -- FORFEIT (set if user leaves during live game) --
  leftAt DateTime?

  // -- TIMESTAMPS --
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([gameId, userId])
  @@index([gameId, score(sort: Desc)])
  @@index([userId, createdAt(sort: Desc)])
}

// ==========================================
// 4. CHAT (Persisted messages)
// ==========================================

model Chat {
  id        Int      @id @default(autoincrement())
  game      Game     @relation(fields: [gameId], references: [id], onDelete: Cascade)
  gameId    String
  user      User     @relation(fields: [userId], references: [id])
  userId    Int
  text      String   @db.VarChar(500)
  createdAt DateTime @default(now())

  @@index([gameId, createdAt])
}

// ==========================================
// 5. NOTIFICATIONS
// ==========================================
model NotificationToken {
  id        Int      @id @default(autoincrement())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    Int
  appFid    Int
  token     String   @db.VarChar(255)
  url       String   @db.VarChar(500)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, appFid])
  @@index([token])
}

// ==========================================
// 6. ADMIN AUDIT LOG
// ==========================================

model AuditLog {
  id      Int  @id @default(autoincrement())
  admin   User @relation(fields: [adminId], references: [id])
  adminId Int

  action     String   @db.VarChar(50)
  entityType String   @db.VarChar(50)
  entityId   String?  @db.VarChar(50)
  details    Json?
  ip         String?  @db.VarChar(45)
  createdAt  DateTime @default(now())

  @@index([adminId, createdAt])
  @@index([entityType, entityId])
}

// ==========================================
// 7. ADMIN INVITE CODES (One-Time Use)
// ==========================================

model InviteCode {
  id        Int       @id @default(autoincrement())
  code      String    @unique @db.VarChar(6)
  usedById  Int?
  usedAt    DateTime?
  createdAt DateTime  @default(now())
  note      String?   @db.VarChar(100)

  usedBy User? @relation(fields: [usedById], references: [id])

  @@index([code])
}
